# 快速开始

![Three.js 对象组件](https://s1.ax1x.com/2020/10/28/B1NFdf.md.png)

首先有一个 Renderer。这可以说是 three.js 的主要对象。你传入了一个 Scene 和一个 Camera 到 Renderer 里面，然后他来渲染（画）出在相机视椎体中的 3D 场景，作为一个 2D 的图片在画布上。然后有一个场景图（Screen Graph），它是一个类似树的结构，由很多对象组成，比如一个 Scene 对象 ，多个 Mesh 对象，Light 对象，Group，Object3D，和 Camera 对象。一个 Scene 对象定义了场景图最基本的要素，并包含背景色和雾等属性。这些对象定义了一个分层的父/子树的结构，并且展现出对象出现的地方和他们的方向。子对象的位置和方向是相对于父对象而言的。比如说汽车的轮子是汽车的子对象，这样移动和定位汽车就会自动移动轮子。注意图中 Camera 是一半在场景图中，一半在场景图外的。这表示在 three.js 中，不像其他的对象一样，一个 Camera 不一定要在场景图中起作用。就像其他的对象一样，一个 Camera，作为一些其他对象的子对象，将会跟随他的父对象移动和朝向。

Mesh 对象代表用一个特定的 Material 绘制一个特定的 Geometry。Material 对象和 Geometry 对象可以被多个 Mesh 对象使用。比如在不同的位置画两个蓝色立方体，我们会需要两个 Mesh 对象来代表每一个立方体的位置和方向。我们只需要一个 Geometry 来存放立方体的顶点数据，和一个 Material 来定义蓝色就可以了。两个 Mesh 对象都涉及到相同的 Geometry 对象和 Material 对象。Geometry 对象代表一些几何体，比如说球体、立方体、平面、狗、猫、人、树、建筑等的顶点信息。Three.js 提供了多种内置的基本元素 。你也可以创建自定义几何体并且从文件中加载几何体。

Material 对象代表绘制几何体的表面属性，包括使用的颜色，和光亮程度。一个 Material 可以引用一个或多个 Texture 对象，这些对象可以用来，例如，将图像包裹到几何体的表面。Texture 对象通常代表图片要么从图像文件中加载，在画布上形成，要么 由另一个场景渲染出。Light 对象代表不同种类的光。

# Hello Cube

![Cube 应用结构](https://s1.ax1x.com/2020/10/28/B1UFXR.md.png)

```js
// Online Demo: https://codepen.io/pen/?&editable=true&editors=101=https%3A%2F%2Fthreejsfundamentals.org%2F
import * as THREE from "https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js";

function main() {
  const canvas = document.querySelector("#c");
  const renderer = new THREE.WebGLRenderer({ canvas });

  const fov = 75;
  const aspect = 2; // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;

  const scene = new THREE.Scene();

  {
    const color = 0xffffff;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);
  }

  const boxWidth = 1;
  const boxHeight = 1;
  const boxDepth = 1;
  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

  const material = new THREE.MeshPhongMaterial({ color: 0x44aa88 }); // greenish blue

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  function render(time) {
    time *= 0.001; // convert time to seconds

    cube.rotation.x = time;
    cube.rotation.y = time;

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}

main();
```

## 相机

这里对于相机的位置进行简要分析：

- fov 是 field of view 的缩写。当前的情况是垂直方向为 75 度。注意 three.js 中大多数的角用弧度表示，但是因为某些原因透视摄像机使用角度表示。
- aspect 指 canvas 的显示比例。但是在默认情况下 canvas 是 300x150 像素，所以 aspect 为 300/150 或者说 2.。
- near 和 far 代表摄像机前方将要被渲染的空间。任何在这个范围前面或者后面的物体都将被裁剪(不绘制)。

这四个参数定义了一个 "frustum"（译者注：视椎体）。frustum 是指一个像被削去顶部 的金字塔形状。换句话说，可以把"frustum"想象成其他形状比如球体、立方体、棱柱体、截椎体。近平面和远平面的高度由 fov 决定。两个平面的宽度由 fov 和 aspect 决定。截椎体内部的物体将被绘制，截椎体外的东西将不会被绘制。

摄像机默认指向 Z 轴负方向，上方向朝向 Y 轴正方向。我们将会把立方体 放置在坐标原点，所以我们需要往后移动摄像机才能看到物体。

![xz 轴示意图](https://s1.ax1x.com/2020/10/28/B1BRXQ.png)

上面的示意图中我们能看到摄像机的位置在 z = 2。它朝向 Z 轴负方向。我们的截椎体从摄像机前方的 0.1 到 5。因为这张图是俯视图,fov 会受到 aspect 的影响。canvas 的宽度是高度的两倍，所以水平视角会比我们设置的垂直视角 75 度要大。

## 动画

我们来让立方体旋转起来，希望 能看出是三维的。为了让它动起来我们需要在渲染循环函数中使用 requestAnimationFrame.

```js
function render(time) {
  time *= 0.001; // convert time to seconds

  cube.rotation.x = time;
  cube.rotation.y = time;

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
```

requestAnimationFrame 会告诉浏览器你有那些东西想要做动画。传入一个函数作为回调函数。我们这里的函数是 render。浏览器 会调用你的函数然后如果你更新了跟页面显示有关的东西， 浏览器就会重新渲染页面。我们这里是调用 three.js 的 renderer.render 函数来绘制我们的场景。

requestAnimationFrame 会传入从页面加载到 我们函数的时间. 传入的时间是毫秒数。我发现 用秒会更简单所以我们把它转换成秒。

## 灯光

效果好了一些但还是很难看出是三维的。添加灯光会有帮助， 所以我们来添加一盏灯光。three.js 中有很多种类型的灯光，现在我们先创建一盏平行光。

```js
{
  const color = 0xffffff;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(-1, 2, 4);
  scene.add(light);
}
```

平行光有一个位置和目标点。默认值都为 0, 0, 0。我们这里 设置灯光的位置为 -1, 2, 4 所以它位于摄像机前面的 稍微左上方一点。目标点还是 0, 0, 0 所以它朝向 坐标原点。我们还需要改变材质。MeshBasicMaterial 材质不会受到灯光的 影响。我们将他改成会受灯光影响的 MeshPhongMaterial 材质。

```js
- const material = new THREE.MeshBasicMaterial({color: 0x44aa88});  // greenish blue
+ const material = new THREE.MeshPhongMaterial({color: 0x44aa88});  // greenish blue
```

![灯光效果](https://s1.ax1x.com/2020/10/28/B1DjxS.png)

## 多个立方体

为了更有乐趣我们再添加两个立方体。每个立方体将会使用同一个几何体但是不同的材质， 这样每个立方体将会是不同的颜色。首先我们创建一个根据指定的颜色生成新材质的函数。然后函数会根据指定的几何体生成一个 mesh， 最后将他添加进场景并设置 X 轴的位置。

```js
function makeInstance(geometry, color, x) {
  const material = new THREE.MeshPhongMaterial({ color });

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  cube.position.x = x;

  return cube;
}
```

然后我们将使用三种不同的颜色和 X 轴位置调用三次函数， 将生成的网格实例存在一个数组中。

```js
const cubes = [
  makeInstance(geometry, 0x44aa88, 0),
  makeInstance(geometry, 0x8844aa, -2),
  makeInstance(geometry, 0xaa8844, 2),
];
```

最后我们将在渲染函数中旋转三个立方体。我们 给每个立方体设置了稍微不同的旋转角度。

```js
function render(time) {
  time *= 0.001;  // convert time to seconds

  cubes.forEach((cube, ndx) => {
    const speed = 1 + ndx * .1;
    const rot = time * speed;
    cube.rotation.x = rot;
    cube.rotation.y = rot;
  });

  ...
```

# 响应式设计

让一个网页是响应式的通常是指让网页能在从桌面到平板再到手机不同尺寸的显示器上显示良好。

## 拉伸与块状化

一般来说，我们的响应式设计需要解决两个问题：

- 第一是我们的立方体被拉伸了。他们不是立方体了更像是个盒子太高或者太宽。在新标签中打开它然后改变尺寸你就能看到立方体是怎么在宽高上被拉伸的。
- 另一个问题是立方体看起来分辨率太低或者说块状化或者有点模糊，将窗口拉伸的非常大你就能看到问题。

我们先解决拉伸的问题。为此我们要将相机的 aspect 设置为 canvas 的宽高比。我们可以通过 canvas 的 clientWidth 和 clientHeight 属性来实现。

```js
function render(time) {
  time *= 0.001;

  const canvas = renderer.domElement;
  camera.aspect = canvas.clientWidth / canvas.clientHeight;
  camera.updateProjectionMatrix();

  // ...
}
```

我们现在来解决块状化的问题，canvas 元素有两个尺寸。一个是 canvas 在页面上的显示尺寸， 是我们用 CSS 来设置的。另一个尺寸是 canvas 本身像素的数量。这和图片一样。比如我们有一个 128x64 像素的图片然后我们可以通过 CSS 让它显示为 400x200 像素。

```html
<img src="some128x64image.jpg" style="width:400px; height:200px" />
```

一个 canvas 的内部尺寸，它的分辨率，通常被叫做 drawingbuffer 尺寸。在 three.js 中我们可以通过调用 renderer.setSize 来设置 canvas 的 drawingbuffer，再一次，我们可以使用 canvas 的 clientWidth 和 clientHeight 属性。

```js
function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
```

一旦我们知道了是否需要调整大小我们就调用 renderer.setSize 然后 传入新的宽高。在末尾传入 false 很重要。render.setSize 默认会设置 canvas 的 CSS 尺寸但这并不是我们想要的。我们希望浏览器能继续工作就像其他使用 CSS 来定义尺寸的其他元素。我们不希望 three.js 使用 canvas 和其他元素不一样。注意如果我们的 canvas 大小被调整了那函数会返回 true。我们可以利用 这个来检查是否有其他的东西应该更新。我们修改渲染循环 来使用我们的新函数。

```js
function render(time) {
  time *= 0.001;

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }

  ...
```

## 应对 HD-DPI 显示器
